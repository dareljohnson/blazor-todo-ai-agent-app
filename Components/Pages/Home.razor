@page "/"
@using BlazorAiAgentTodo.Services
@using BlazorAiAgentTodo.Models
@using Microsoft.JSInterop
@inject IAgentService AgentService
@inject ITodoService TodoService
@inject IChatService ChatService
@inject IJSRuntime JSRuntime

<PageTitle>AI Agent Todo App</PageTitle>

<div class="app-container">
    <div class="app-header">
        <h1>ü§ñ AI Agent Todo App</h1>
        <p>Powered by OpenAI GPT-5.2</p>
    </div>

    <div class="main-layout">
        <!-- Left Sidebar: Todo List -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">
                    <span class="card-icon">‚úì</span>
                    Agent Tasks
                </h2>
                <span class="status-badge @(Todos.Any(t => t.IsActive) ? "active" : "pending")">
                    @Todos.Count(t => t.IsCompleted)/@Todos.Count
                </span>
            </div>
            
            @if (Todos.Any())
            {
                <div class="todo-list">
                    @foreach (var todo in Todos)
                    {
                        <div class="todo-item @(todo.IsActive ? "active" : "") @(todo.IsCompleted ? "completed" : "")">
                            <div class="todo-header">
                                <div class="todo-description math-content">@((MarkupString)FormatInlineMarkdown(todo.Description))</div>
                                <div class="todo-header-actions">
                                    <button class="copy-button" @onclick="() => CopyTodoToClipboard(todo)" title="Copy to clipboard">
                                        üìã
                                    </button>
                                    <span class="status-badge @(todo.IsCompleted ? "completed" : todo.IsActive ? "active" : "pending")">
                                        @(todo.IsCompleted ? "‚úì Done" : todo.IsActive ? "‚öô Active" : "‚óã Pending")
                                    </span>
                                </div>
                            </div>
                            
                            @if (!string.IsNullOrEmpty(todo.CompletionNotes) || todo.Duration > TimeSpan.Zero)
                            {
                                <div class="todo-meta">
                                    @if (todo.Duration > TimeSpan.Zero)
                                    {
                                        <span class="meta-item">
                                            <span>‚è±</span>
                                            <span>@todo.GetDurationDisplay()</span>
                                        </span>
                                    }
                                    @if (!string.IsNullOrEmpty(todo.ToolUsed))
                                    {
                                        <span class="meta-item">
                                            <span>üîß</span>
                                            <span>@todo.ToolUsed</span>
                                        </span>
                                    }
                                </div>
                            }
                            
                            @if (!string.IsNullOrEmpty(todo.CompletionNotes))
                            {
                                <div class="todo-notes math-content">
                                    @((MarkupString)FormatInlineMarkdown(todo.CompletionNotes))
                                </div>
                            }
                        </div>
                    }
                </div>
            }
            else
            {
                <div class="empty-state">
                    <div class="empty-state-icon">üìù</div>
                    <div class="empty-state-text">No tasks yet. Start a conversation to see agent tasks!</div>
                </div>
            }
        </div>

        <!-- Right Main Area: Chat & Report -->
        <div class="chat-section">
            <!-- Chat Messages -->
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">
                        <span class="card-icon">üí¨</span>
                        Conversation
                    </h2>
                    <button class="btn btn-secondary" @onclick="HandleNewChat" disabled="@IsProcessing">
                        üîÑ New Chat
                    </button>
                </div>
                
                @if (Messages.Any())
                {
                    <div class="chat-messages">
                        @foreach (var message in Messages)
                        {
                            var lowerRole = message.Role.ToString().ToLowerInvariant();
                            var (text, imageUrl) = ExtractImage(message.Content);
                            
                            <div class="chat-message @lowerRole">
                                <div class="message-avatar">
                                    @(lowerRole == "user" ? "üë§" : "ü§ñ")
                                </div>
                                <div class="message-content">
                                    <div class="message-header-row">
                                        <div class="message-role">@message.Role</div>
                                        @if (lowerRole == "assistant")
                                        {
                                            <button class="message-copy-button" @onclick="() => CopyMessageToClipboard(text)" title="Copy to clipboard">
                                                üìã
                                            </button>
                                        }
                                    </div>
                                    <div class="message-text math-content">
                                        @if (lowerRole == "assistant")
                                        {
                                            @((MarkupString)FormatReport(text))
                                        }
                                        else
                                        {
                                            @((MarkupString)FormatInlineMarkdown(text))
                                        }
                                    </div>
                                    @if (!string.IsNullOrEmpty(imageUrl))
                                    {
                                        <div class="generated-image">
                                            <img src="@imageUrl" alt="AI Generated Image" />
                                        </div>
                                    }
                                    <div class="message-timestamp">@message.Timestamp.ToString("HH:mm:ss")</div>
                                </div>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <div class="empty-state">
                        <div class="empty-state-icon">üí≠</div>
                        <div class="empty-state-text">Send a message to start chatting with the AI agent!</div>
                    </div>
                }
                
                <!-- Chat Input -->
                <div class="chat-input-area">
                    <textarea 
                        class="chat-input" 
                        placeholder="Ask me to help with calculations, planning, or any task..."
                        @bind="CurrentPrompt"
                        @bind:event="oninput"
                        disabled="@IsProcessing"
                        @onkeydown="HandleKeyDown"></textarea>
                    
                    <div class="chat-actions">
                        <button class="btn btn-primary" @onclick="HandleSendMessage" disabled="@(IsProcessing || string.IsNullOrWhiteSpace(CurrentPrompt))">
                            @if (IsProcessing)
                            {
                                <span class="loading">
                                    <span class="spinner"></span>
                                    Processing...
                                </span>
                            }
                            else
                            {
                                <span>‚úà Send Message</span>
                            }
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    private string CurrentPrompt { get; set; } = string.Empty;
    private bool IsProcessing { get; set; } = false;
    private List<ChatMessage> Messages { get; set; } = new();
    private List<TodoItem> Todos { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        await RefreshData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Render any math that exists on initial load (including persisted messages)
            await Task.Delay(200);
            await RenderMathAsync();
        }
    }

    private async Task HandleSendMessage()
    {
        if (string.IsNullOrWhiteSpace(CurrentPrompt) || IsProcessing)
            return;

        IsProcessing = true;
        var userPrompt = CurrentPrompt.Trim();
        CurrentPrompt = string.Empty;

        // Validate prompt length
        if (userPrompt.Length > 5000)
        {
            await ShowErrorNotification("Prompt is too long. Maximum 5,000 characters.");
            IsProcessing = false;
            return;
        }

        try
        {
            // Add user message
            var userMessage = ChatMessageFactory.CreateUser(userPrompt);
            Messages.Add(userMessage);
            await ChatService.AddMessageAsync(userMessage);
            StateHasChanged();

            // Process with agent - refresh todos in real-time
            var response = await AgentService.ProcessPromptAsync(
                userPrompt,
                onUpdate: async (update) =>
                {
                    await RefreshData();
                    await InvokeAsync(StateHasChanged);
                }
            );

            // Wait for all tasks to be marked complete
            var maxWaitTime = TimeSpan.FromSeconds(30);
            var startTime = DateTime.UtcNow;
            while (DateTime.UtcNow - startTime < maxWaitTime)
            {
                await RefreshData();
                
                // Check if all todos are completed
                if (Todos.Any() && Todos.All(t => t.IsCompleted))
                {
                    break;
                }
                
                await Task.Delay(100);
            }
            
            // Final refresh
            await RefreshData();
            
            // Now add assistant response after all tasks are done
            var assistantMessage = ChatMessageFactory.CreateAssistant(response);
            Messages.Add(assistantMessage);
            await ChatService.AddMessageAsync(assistantMessage);

            await RefreshData();
            StateHasChanged();
            
            // Render math expressions with delay to ensure DOM is fully updated
            await Task.Delay(200);
            await RenderMathAsync();
            StateHasChanged();
        }
        catch (OperationCanceledException)
        {
            await ShowErrorNotification("Request was cancelled.");
        }
        catch (ArgumentException ex)
        {
            await ShowErrorNotification($"Invalid input: {ex.Message}");
        }
        catch (HttpRequestException ex)
        {
            await ShowErrorNotification($"Network error: {ex.Message}");
        }
        catch (InvalidOperationException ex)
        {
            await ShowErrorNotification($"Configuration error: {ex.Message}");
        }
        catch (Exception ex)
        {
            await ShowErrorNotification($"Unexpected error: {ex.Message}");
            // In production, log this to a proper logging system
            Console.Error.WriteLine($"Unhandled exception in HandleSendMessage: {ex}");
        }
        finally
        {
            IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task ShowErrorNotification(string message)
    {
        var errorMessage = ChatMessageFactory.CreateAssistant($"‚ùå **Error**: {message}");
        Messages.Add(errorMessage);
        await ChatService.AddMessageAsync(errorMessage);
        StateHasChanged();
    }

    private async Task HandleNewChat()
    {
        CurrentPrompt = string.Empty;
        await ChatService.ClearAsync();
        await TodoService.ClearAsync();
        await RefreshData();
    }

    private async Task RefreshData()
    {
        Todos = await TodoService.GetAllAsync();
        Messages = await ChatService.GetMessagesAsync();
        StateHasChanged();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && e.CtrlKey && !IsProcessing)
        {
            await HandleSendMessage();
        }
    }

    private string FormatReport(string report)
    {
        if (string.IsNullOrEmpty(report))
            return string.Empty;

        // DEBUG: Log input
        Console.WriteLine($"[FormatReport] Input length: {report.Length}, first 100 chars: {report.Substring(0, Math.Min(100, report.Length))}");

        // Step 1: Extract and protect ALL math expressions first (including multi-line)
        // Support both LaTeX \(...\), \[...\] and Markdown $...$, $$...$$ syntax
        // Make inline math $ pattern restrictive: no newlines, no commas (currency uses commas)
        var mathPlaceholders = new System.Collections.Generic.List<string>();
        // Display math can be multi-line, inline math cannot and must not contain commas
        var mathPattern = @"\$\$([^$]+?)\$\$|\\\[([^\]]+?)\\\]|\\\(([^)]+?)\\\)|\$([a-zA-Z0-9+\-*/=^(){}\[\]\\\s\.]+?)\$";
        var mathIndex = 0;
        
        report = System.Text.RegularExpressions.Regex.Replace(report, mathPattern, match => {
            var placeholder = $"___MATH_{mathIndex}___";
            // Convert LaTeX syntax to KaTeX-friendly $ syntax
            var mathContent = match.Value;
            if (mathContent.StartsWith("\\[") && mathContent.EndsWith("\\]"))
            {
                // Display math \[...\] -> $$...$$
                mathContent = "$$" + mathContent.Substring(2, mathContent.Length - 4) + "$$";
            }
            else if (mathContent.StartsWith("\\(") && mathContent.EndsWith("\\)"))
            {
                // Inline math \(...\) -> $...$
                mathContent = "$" + mathContent.Substring(2, mathContent.Length - 4) + "$";
            }
            mathPlaceholders.Add(mathContent);
            Console.WriteLine($"[FormatReport] Extracted math {mathIndex}: {match.Value} -> {mathContent}");
            mathIndex++;
            return placeholder;
        }, System.Text.RegularExpressions.RegexOptions.Singleline);

        // Step 2: Process lines for structure
        var lines = report.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        var formatted = new System.Text.StringBuilder();
        var inList = false;

        foreach (var line in lines)
        {
            var trimmed = line.Trim();
            
            // Handle numbered lists (e.g., "1. ", "2. ")
            if (System.Text.RegularExpressions.Regex.IsMatch(trimmed, @"^\d+\.\s"))
            {
                if (!inList)
                {
                    formatted.Append("<ol style='margin-left: 1.5rem; margin-bottom: 1rem;'>");
                    inList = true;
                }
                var content = System.Text.RegularExpressions.Regex.Replace(trimmed, @"^\d+\.\s", "");
                formatted.Append($"<li style='margin-bottom: 0.5rem;'>{FormatInlineMarkdownWithoutMath(content)}</li>");
            }
            else
            {
                if (inList)
                {
                    formatted.Append("</ol>");
                    inList = false;
                }
                formatted.Append($"<p style='margin-bottom: 0.75rem;'>{FormatInlineMarkdownWithoutMath(trimmed)}</p>");
            }
        }

        if (inList)
        {
            formatted.Append("</ol>");
        }

        var result = formatted.ToString();
        
        // Step 3: Restore math expressions at the end
        for (int i = 0; i < mathPlaceholders.Count; i++)
        {
            result = result.Replace($"___MATH_{i}___", mathPlaceholders[i]);
        }

        return result;
    }

    private string FormatInlineMarkdownWithoutMath(string text)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;
            
        // HTML encode everything (math already extracted)
        text = System.Net.WebUtility.HtmlEncode(text);
        
        // Apply markdown formatting
        // Bold **text**
        text = System.Text.RegularExpressions.Regex.Replace(text, @"\*\*(.+?)\*\*", "<strong>$1</strong>");
        
        // Inline code `code`
        text = System.Text.RegularExpressions.Regex.Replace(text, @"`(.+?)`", "<code style='background: #f3f4f6; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-family: monospace;'>$1</code>");
        
        return text;
    }

    private string FormatInlineMarkdown(string text)
    {
        if (string.IsNullOrEmpty(text))
            return string.Empty;
            
        // Step 1: Protect math expressions (support LaTeX and Markdown syntax)
        // Use Singleline option for display math only, inline math must not span lines or contain commas
        var mathPlaceholders = new System.Collections.Generic.List<string>();
        // Display math can be multi-line, inline math cannot contain newlines or commas (currency indicator)
        var mathPattern = @"\$\$([^$]+?)\$\$|\\\[([^\]]+?)\\\]|\\\(([^)]+?)\\\)|\$([a-zA-Z0-9+\-*/=^(){}\[\]\\\s\.]+?)\$";
        var mathIndex = 0;
        
        text = System.Text.RegularExpressions.Regex.Replace(text, mathPattern, match => {
            var placeholder = $"___MATH_{mathIndex}___";
            // Convert LaTeX syntax to KaTeX-friendly $ syntax
            var mathContent = match.Value;
            if (mathContent.StartsWith("\\[") && mathContent.EndsWith("\\]"))
            {
                mathContent = "$$" + mathContent.Substring(2, mathContent.Length - 4) + "$$";
            }
            else if (mathContent.StartsWith("\\(") && mathContent.EndsWith("\\)"))
            {
                mathContent = "$" + mathContent.Substring(2, mathContent.Length - 4) + "$";
            }
            mathPlaceholders.Add(mathContent);
            mathIndex++;
            return placeholder;
        }, System.Text.RegularExpressions.RegexOptions.Singleline);
        
        // Step 2: HTML encode everything (including placeholders)
        text = System.Net.WebUtility.HtmlEncode(text);
        
        // Step 3: Apply markdown formatting on encoded text
        // Bold **text**
        text = System.Text.RegularExpressions.Regex.Replace(text, @"\*\*(.+?)\*\*", "<strong>$1</strong>");
        
        // Inline code `code`
        text = System.Text.RegularExpressions.Regex.Replace(text, @"`(.+?)`", "<code style='background: #f3f4f6; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-family: monospace;'>$1</code>");
        
        // Step 4: Restore math expressions (unencoded for KaTeX)
        for (int i = 0; i < mathPlaceholders.Count; i++)
        {
            text = text.Replace($"___MATH_{i}___", mathPlaceholders[i]);
        }
        
        return text;
    }

    private (string text, string imageUrl) ExtractImage(string content)
    {
        if (string.IsNullOrEmpty(content))
            return (string.Empty, string.Empty);

        // Look for [IMAGE:data:image/png;base64,...] pattern
        var imagePattern = @"\[IMAGE:(data:image/[^]]+)\]";
        var match = System.Text.RegularExpressions.Regex.Match(content, imagePattern);
        
        if (match.Success)
        {
            var imageUrl = match.Groups[1].Value;
            var textWithoutImage = System.Text.RegularExpressions.Regex.Replace(content, imagePattern, "").Trim();
            return (textWithoutImage, imageUrl);
        }
        
        return (content, string.Empty);
    }

    private async Task CopyTodoToClipboard(TodoItem todo)
    {
        try
        {
            var textToCopy = todo.Description;
            if (!string.IsNullOrEmpty(todo.CompletionNotes))
            {
                textToCopy += $"\n\n{todo.CompletionNotes}";
            }
            
            await JSRuntime.InvokeVoidAsync("clipboardCopy.copyToClipboard", textToCopy);
        }
        catch (Exception)
        {
            // Silently fail - clipboard API might not be available
        }
    }

    private async Task CopyMessageToClipboard(string text)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("clipboardCopy.copyToClipboard", text);
        }
        catch (Exception)
        {
            // Silently fail - clipboard API might not be available
        }
    }

    private async Task RenderMathAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("renderMath");
        }
        catch (Exception)
        {
            // Ignore JS interop errors
        }
    }
}
